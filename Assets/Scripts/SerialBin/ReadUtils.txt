private class SerialBinBinaryReader : IDisposable
	{
		public Stream BaseStream { get { return reader.BaseStream; } }

		public SerialBinBinaryReader(Stream input)
		{
			reader = new BinaryReader(input);
		}
		public SerialBinBinaryReader(Stream input, System.Text.Encoding encoding)
		{
			reader = new BinaryReader(input, encoding);
		}

		void IDisposable.Dispose()
		{
			Close();
		}
		~SerialBinBinaryReader()
		{
			Close();
		}
		public void Close()
		{
			if(reader != null)
			{
				reader.Close();
				reader = null;
			}
		}

		public byte ReadByte()
		{
			return reader.ReadByte();
		}
		public sbyte ReadSByte()
		{
			return reader.ReadSByte();
		}

		public void Read(byte[] buffer, int index, int count)
		{
			reader.Read(buffer, index, count);
		}
		public byte[] ReadBytes(int count)
		{
			return reader.ReadBytes(count);
		}

		public byte[] ReadRestOfBytes()
		{
			var remainingByteCount = reader.BaseStream.Length - reader.BaseStream.Position;

			Debug.Assert(remainingByteCount <= int.MaxValue);

			return reader.ReadBytes((int)remainingByteCount);
		}
		public void ReadRestOfBytes(byte[] buffer, int startIndex)
		{
			var remainingByteCount = reader.BaseStream.Length - reader.BaseStream.Position;

			Debug.Assert((startIndex >= 0) && (remainingByteCount <= int.MaxValue) && ((startIndex + remainingByteCount) <= buffer.Length));

			reader.Read(buffer, startIndex, (int)remainingByteCount);
		}

		public string ReadASCIIString(int length)
		{
			Debug.Assert(length >= 0);

			return System.Text.Encoding.ASCII.GetString(reader.ReadBytes(length));
		}
		public string ReadPossiblyNullTerminatedASCIIString(int lengthIncludingPossibleNullTerminator)
		{
			Debug.Assert(lengthIncludingPossibleNullTerminator > 0);

			var bytes = reader.ReadBytes(lengthIncludingPossibleNullTerminator);

			// Ignore the null terminator.
			var charCount = (Utils.Last(bytes) != 0) ? bytes.Length : (bytes.Length - 1);

			return System.Text.Encoding.ASCII.GetString(bytes, 0, charCount);
		}

		#region Little Endian
		public bool ReadBool8LE()
		{
			return ReadUInt8LE() != 0;
		}
		public bool ReadBool16LE()
		{
			return ReadUInt16LE() != 0;
		}
		public bool ReadBool32LE()
		{
			return ReadUInt32LE() != 0;
		}
		public bool ReadBool64LE()
		{
			return ReadUInt64LE() != 0;
		}

		public ushort ReadUInt16LE()
		{
			reader.Read(readBuffer, 0, 2);

			return (ushort)((readBuffer[1] << 8) | readBuffer[0]);
		}
		public uint ReadUInt32LE()
		{
			reader.Read(readBuffer, 0, 4);

			return ((uint)readBuffer[3] << 24) | ((uint)readBuffer[2] << 16) | ((uint)readBuffer[1] << 8) | readBuffer[0];
		}
		public ulong ReadUInt64LE()
		{
			reader.Read(readBuffer, 0, 8);

			return ((ulong)readBuffer[7] << 56) | ((ulong)readBuffer[6] << 48) | ((ulong)readBuffer[5] << 40) | ((ulong)readBuffer[4] << 32) | ((ulong)readBuffer[3] << 24) | ((ulong)readBuffer[2] << 16) | ((ulong)readBuffer[1] << 8) | readBuffer[0];
		}

		public short ReadInt16LE()
		{
			var shortAsUShort = ReadUInt16LE();

			unsafe
			{
				return *((short*)(&shortAsUShort));
			}
		}
		public int ReadInt32LE()
		{
			var intAsUInt = ReadUInt32LE();

			unsafe
			{
				return *((int*)(&intAsUInt));
			}
		}
		public long ReadInt64LE()
		{
			var longAsULong = ReadUInt64LE();

			unsafe
			{
				return *((long*)(&longAsULong));
			}
		}

		public float ReadSingleLE()
		{
			var singleAsUInt = ReadUInt32LE();

			unsafe
			{
				return *((float*)(&singleAsUInt));
			}
		}
		public double ReadDoubleLE()
		{
			var doubleAsUInt = ReadUInt64LE();

			unsafe
			{
				return *((double*)(&doubleAsUInt));
			}
		}

		public byte[] ReadLength32PrefixedBytesLE()
		{
			var length = ReadUInt32LE();
			return reader.ReadBytes((int)length);
		}
		public string ReadLength32PrefixedASCIIStringLE()
		{
			return System.Text.Encoding.ASCII.GetString(ReadLength32PrefixedBytesLE());
		}

		public Vector2 ReadVector2LE()
		{
			var x = ReadSingleLE();
			var y = ReadSingleLE();

			return new Vector2(x, y);
		}
		public Vector3 ReadVector3LE()
		{
			var x = ReadSingleLE();
			var y = ReadSingleLE();
			var z = ReadSingleLE();

			return new Vector3(x, y, z);
		}
		public Vector4 ReadVector4LE()
		{
			var x = ReadSingleLE();
			var y = ReadSingleLE();
			var z = ReadSingleLE();
			var w = ReadSingleLE();

			return new Vector4(x, y, z, w);
		}

		/// <summary>
		/// Reads a column-major 3x3 matrix but returns a functionally equivalent 4x4 matrix.
		/// </summary>
		public Matrix4x4 ReadColumnMajorMatrix3x3LE()
		{
			var matrix = new Matrix4x4();

			for(int columnIndex = 0; columnIndex < 4; columnIndex++)
			{
				for(int rowIndex = 0; rowIndex < 4; rowIndex++)
				{
					// If we're in the 3x3 part of the matrix, read values. Otherwise, use the identity matrix.
					if(rowIndex <= 2 && columnIndex <= 2)
					{
						matrix[rowIndex, columnIndex] = ReadSingleLE();
					}
					else
					{
						matrix[rowIndex, columnIndex] = (rowIndex == columnIndex) ? 1 : 0;
					}
				}
			}

			return matrix;
		}

		/// <summary>
		/// Reads a row-major 3x3 matrix but returns a functionally equivalent 4x4 matrix.
		/// </summary>
		public Matrix4x4 ReadRowMajorMatrix3x3LE()
		{
			var matrix = new Matrix4x4();

			for(int rowIndex = 0; rowIndex < 4; rowIndex++)
			{
				for(int columnIndex = 0; columnIndex < 4; columnIndex++)
				{
					// If we're in the 3x3 part of the matrix, read values. Otherwise, use the identity matrix.
					if(rowIndex <= 2 && columnIndex <= 2)
					{
						matrix[rowIndex, columnIndex] = ReadSingleLE();
					}
					else
					{
						matrix[rowIndex, columnIndex] = (rowIndex == columnIndex) ? 1 : 0;
					}
				}
			}

			return matrix;
		}

		public Matrix4x4 ReadColumnMajorMatrix4x4LE()
		{
			var matrix = new Matrix4x4();

			for(int columnIndex = 0; columnIndex < 4; columnIndex++)
			{
				for(int rowIndex = 0; rowIndex < 4; rowIndex++)
				{
					matrix[rowIndex, columnIndex] = ReadSingleLE();
				}
			}

			return matrix;
		}
		public Matrix4x4 ReadRowMajorMatrix4x4LE()
		{
			var matrix = new Matrix4x4();

			for(int rowIndex = 0; rowIndex < 4; rowIndex++)
			{
				for(int columnIndex = 0; columnIndex < 4; columnIndex++)
				{
					matrix[rowIndex, columnIndex] = ReadSingleLE();
				}
			}

			return matrix;
		}

		public Quaternion ReadQuaternionWFirstLE()
		{
			float w = ReadSingleLE();
			float x = ReadSingleLE();
			float y = ReadSingleLE();
			float z = ReadSingleLE();

			return new Quaternion(x, y, z, w);
		}
		public Quaternion ReadQuaternionWLastLE()
		{
			float x = ReadSingleLE();
			float y = ReadSingleLE();
			float z = ReadSingleLE();
			float w = ReadSingleLE();

			return new Quaternion(x, y, z, w);
		}
		#endregion

		private BinaryReader reader;

		// A buffer for read bytes the size of a decimal variable. Created to minimize allocations. 
		private byte[] readBuffer = new byte[16];
	}